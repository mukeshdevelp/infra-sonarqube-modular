pipeline {
    agent any
    environment {
        AWS_CREDS = credentials('aws-credentials')
        // Terraform variables (adjust as per your setup)
        TF_VAR_region = 'us-east-1'
        //TF_VAR_bucket_name = 'sonarqube-terraform-state-123'
        //TF_VAR_dynamodb_table = 'terraform-locks-123'
        SSH_KEY_PATH = "${WORKSPACE}/.ssh/sonarqube-key.pem"
    }
    stages {
        stage('Git Checkout') {
            steps {
                checkout([$class: 'GitSCM',
                          branches: [[name: '*/main']],
                          doGenerateSubmoduleConfigurations: false,
                          extensions: [],
                          userRemoteConfigs: [[url: 'https://github.com/mukeshdevelp/infra-sonarqube-modular.git', credentialsId: 'github-user-password']]])
            }
        }
        stage('AWS CLI Test & Terraform Init') {
            steps {
                withCredentials([[$class: 'AmazonWebServicesCredentialsBinding',
                                  credentialsId: 'aws-credentials',
                                  accessKeyVariable: 'AWS_ACCESS_KEY_ID',
                                  secretKeyVariable: 'AWS_SECRET_ACCESS_KEY']]) {
                    sh '''
                        aws s3 ls
                        terraform init
                        echo "terraform initialized"
                    '''
                }
            }
        }
        stage('Terraform Formatting') {
            steps { sh 'terraform fmt && echo "formatted terraform code"' }
        }
        stage('Terraform Validate') {
            steps { sh 'terraform validate && echo "validated terraform code"' }
        }
        stage('Terraform Plan') {
            steps { sh 'terraform plan && echo "planning terraform code"' }
        }
        stage('Terraform apply') {
            steps { sh 'terraform apply --auto-approve && echo "creating infra"' }
        }
        stage('storing the private ips'){
            sh ./store_ip.sh
        }
        stage('moving the file in inventory'){
            steps{ 
                sh """
                    cp private_ips.ini ./ansible/inventory.ini
                """
            }
        }
    }
    post {
        success { echo "Stage 1 & 2 completed successfully: repo checked out and infra provisioned." }
        failure { echo "Pipeline failed. Check console output for errors." }
    }
}


/*
 stage('Fetch Terraform Outputs') {
            steps {
                script {
                    // Fetch all outputs as JSON
                    def tfOutputs = sh(
                        script: "terraform output -json",
                        returnStdout: true
                    ).trim()

                    // Parse JSON string to Groovy map
                    def outputs = readJSON text: tfOutputs

                    // Extract variables and store in env
                    env.ALB_DNS_NAME = outputs.alb_dns_name.value
                    env.BASTION_IP = outputs.public_ip_of_bastion.value
                    env.PRIVATE_IPS = outputs.aws_private_instance_ip.value.join(',')
                    env.USERS = outputs.user.value.join(',')
                    env.VPC_ID = outputs.vpc_id.value

                    echo "ALB DNS: ${env.ALB_DNS_NAME}"
                    echo "Bastion IP: ${env.BASTION_IP}"
                    echo "Private IPs: ${env.PRIVATE_IPS}"
                    echo "VPC ID: ${env.VPC_ID}"
                }
            }
        }*/